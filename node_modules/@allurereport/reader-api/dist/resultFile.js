import { lookup } from "mime-types";
import { ReadStream, createReadStream, createWriteStream, existsSync, statSync } from "node:fs";
import "node:fs/promises";
import { basename } from "node:path";
import { pipeline } from "node:stream/promises";
export class BaseResultFile {
    constructor(fileName) {
        this.fileName = fileName;
    }
    getContentType() {
        const res = lookup(this.getOriginalFileName());
        if (res === false) {
            return undefined;
        }
        return res;
    }
    getOriginalFileName() {
        return this.fileName;
    }
    async asJson() {
        return await this.readContent(readSteamToJson);
    }
    async asUtf8String() {
        return await this.readContent(readStreamToString);
    }
    async asBuffer() {
        return await this.readContent(readStreamToBuffer);
    }
    async writeTo(path) {
        await this.readContent(async (stream) => {
            await pipeline(stream, createWriteStream(path));
        });
    }
    async readContent(transform) {
        const content = this.getContent();
        return content ? await transform(content) : undefined;
    }
}
export class BufferResultFile extends BaseResultFile {
    constructor(buffer, fileName) {
        super(basename(fileName));
        this.buffer = buffer;
    }
    getContent() {
        return ReadStream.from(this.buffer, { encoding: "utf8" });
    }
    getContentLength() {
        return this.buffer.length;
    }
}
export class PathResultFile extends BaseResultFile {
    constructor(path, fileName = basename(path)) {
        super(fileName);
        this.path = path;
    }
    getContent() {
        if (existsSync(this.path)) {
            return createReadStream(this.path);
        }
        else {
            return undefined;
        }
    }
    getContentLength() {
        return statSync(this.path, { throwIfNoEntry: false })?.size;
    }
}
export const readSteamToJson = async (stream) => {
    const text = await readStreamToString(stream);
    return JSON.parse(text);
};
export const readStreamToString = async (stream) => {
    const res = await readStreamToBuffer(stream);
    return res.toString("utf-8");
};
export const readStreamToBuffer = async (stream) => {
    const chunks = [];
    for await (const chunk of stream) {
        chunks.push(Buffer.from(chunk));
    }
    return Buffer.concat(chunks);
};
